/**\n * AWS Secrets Manager Provider\n * Production-ready secret management using AWS Secrets Manager\n */\n\nimport {\n  SecretsManagerClient,\n  GetSecretValueCommand,\n  CreateSecretCommand,\n  UpdateSecretCommand,\n  DeleteSecretCommand,\n  DescribeSecretCommand,\n  ResourceNotFoundException,\n  InvalidRequestException,\n  InvalidParameterException,\n  DecryptionFailureException,\n  InternalServiceErrorException,\n  ResourceExistsException\n} from '@aws-sdk/client-secrets-manager';\n\nimport { SecretManagerProvider } from './types.js';\nimport { SecretManagerError } from './errors.js';\n\nexport interface AWSSecretsManagerConfig {\n  region?: string;\n  accessKeyId?: string;\n  secretAccessKey?: string;\n  sessionToken?: string;\n  endpoint?: string;\n  maxRetries?: number;\n  retryDelayOptions?: {\n    base?: number;\n    customBackoff?: (retryCount: number) => number;\n  };\n}\n\nexport interface SecretMetadata {\n  name: string;\n  description?: string;\n  kmsKeyId?: string;\n  tags?: Record<string, string>;\n  versionId?: string;\n  versionStage?: string;\n}\n\n/**\n * AWS Secrets Manager Provider Implementation\n * Provides secure secret storage and retrieval using AWS Secrets Manager\n */\nexport class AWSSecretsManagerProvider implements SecretManagerProvider {\n  private client: SecretsManagerClient;\n  private config: AWSSecretsManagerConfig;\n  private secretPrefix: string;\n\n  constructor(config: AWSSecretsManagerConfig = {}, secretPrefix: string = 'hallucifix/') {\n    this.config = {\n      region: config.region || process.env.AWS_REGION || 'us-east-1',\n      maxRetries: config.maxRetries || 3,\n      ...config\n    };\n    \n    this.secretPrefix = secretPrefix;\n    \n    // Initialize AWS Secrets Manager client\n    this.client = new SecretsManagerClient({\n      region: this.config.region,\n      credentials: this.config.accessKeyId ? {\n        accessKeyId: this.config.accessKeyId,\n        secretAccessKey: this.config.secretAccessKey!,\n        sessionToken: this.config.sessionToken\n      } : undefined,\n      endpoint: this.config.endpoint,\n      maxAttempts: this.config.maxRetries,\n      retryMode: 'adaptive'\n    });\n  }\n\n  /**\n   * Retrieve a single secret from AWS Secrets Manager\n   */\n  async getSecret(key: string): Promise<string | null> {\n    const secretName = this.getSecretName(key);\n    \n    try {\n      const command = new GetSecretValueCommand({\n        SecretId: secretName,\n        VersionStage: 'AWSCURRENT'\n      });\n      \n      const response = await this.client.send(command);\n      \n      if (response.SecretString) {\n        return response.SecretString;\n      } else if (response.SecretBinary) {\n        // Convert binary secret to string\n        const decoder = new TextDecoder();\n        return decoder.decode(response.SecretBinary);\n      }\n      \n      return null;\n    } catch (error) {\n      return this.handleSecretError(error, `Failed to get secret: ${key}`);\n    }\n  }\n\n  /**\n   * Retrieve multiple secrets from AWS Secrets Manager\n   */\n  async getSecrets(keys: string[]): Promise<Record<string, string>> {\n    const secrets: Record<string, string> = {};\n    \n    // Process secrets in parallel with error handling\n    const results = await Promise.allSettled(\n      keys.map(async (key) => {\n        const value = await this.getSecret(key);\n        return { key, value };\n      })\n    );\n    \n    results.forEach((result, index) => {\n      if (result.status === 'fulfilled' && result.value.value !== null) {\n        secrets[result.value.key] = result.value.value;\n      } else if (result.status === 'rejected') {\n        console.warn(`Failed to retrieve secret ${keys[index]}:`, result.reason);\n      }\n    });\n    \n    return secrets;\n  }\n\n  /**\n   * Create or update a secret in AWS Secrets Manager\n   */\n  async setSecret(key: string, value: string, metadata?: SecretMetadata): Promise<void> {\n    const secretName = this.getSecretName(key);\n    \n    try {\n      // First, try to update existing secret\n      try {\n        const updateCommand = new UpdateSecretCommand({\n          SecretId: secretName,\n          SecretString: value,\n          Description: metadata?.description,\n          KmsKeyId: metadata?.kmsKeyId\n        });\n        \n        await this.client.send(updateCommand);\n        console.log(`Secret updated successfully: ${key}`);\n        return;\n      } catch (error) {\n        // If secret doesn't exist, create it\n        if (error instanceof ResourceNotFoundException) {\n          const createCommand = new CreateSecretCommand({\n            Name: secretName,\n            SecretString: value,\n            Description: metadata?.description || `Secret for ${key}`,\n            KmsKeyId: metadata?.kmsKeyId,\n            Tags: metadata?.tags ? Object.entries(metadata.tags).map(([Key, Value]) => ({ Key, Value })) : [\n              { Key: 'Application', Value: 'HalluciFix' },\n              { Key: 'Environment', Value: process.env.NODE_ENV || 'development' },\n              { Key: 'ManagedBy', Value: 'HalluciFix-Config-System' }\n            ]\n          });\n          \n          await this.client.send(createCommand);\n          console.log(`Secret created successfully: ${key}`);\n          return;\n        }\n        \n        throw error;\n      }\n    } catch (error) {\n      throw this.handleSecretError(error, `Failed to set secret: ${key}`, false);\n    }\n  }\n\n  /**\n   * Delete a secret from AWS Secrets Manager\n   */\n  async deleteSecret(key: string, forceDelete: boolean = false): Promise<void> {\n    const secretName = this.getSecretName(key);\n    \n    try {\n      const command = new DeleteSecretCommand({\n        SecretId: secretName,\n        ForceDeleteWithoutRecovery: forceDelete,\n        RecoveryWindowInDays: forceDelete ? undefined : 7 // 7-day recovery window by default\n      });\n      \n      await this.client.send(command);\n      console.log(`Secret ${forceDelete ? 'permanently deleted' : 'scheduled for deletion'}: ${key}`);\n    } catch (error) {\n      throw this.handleSecretError(error, `Failed to delete secret: ${key}`, false);\n    }\n  }\n\n  /**\n   * Check if a secret exists in AWS Secrets Manager\n   */\n  async secretExists(key: string): Promise<boolean> {\n    const secretName = this.getSecretName(key);\n    \n    try {\n      const command = new DescribeSecretCommand({\n        SecretId: secretName\n      });\n      \n      await this.client.send(command);\n      return true;\n    } catch (error) {\n      if (error instanceof ResourceNotFoundException) {\n        return false;\n      }\n      \n      // For other errors, we can't determine existence\n      console.warn(`Error checking secret existence for ${key}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * List all secrets with the configured prefix\n   */\n  async listSecrets(): Promise<string[]> {\n    try {\n      // Note: AWS SDK v3 doesn't have ListSecrets in the basic client\n      // This would require additional implementation with pagination\n      // For now, return empty array and log warning\n      console.warn('listSecrets not implemented - requires additional AWS SDK setup');\n      return [];\n    } catch (error) {\n      console.warn('Failed to list secrets:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Test connectivity to AWS Secrets Manager\n   */\n  async testConnection(): Promise<boolean> {\n    try {\n      // Try to describe a non-existent secret to test connectivity\n      const testSecretName = `${this.secretPrefix}connection-test-${Date.now()}`;\n      \n      const command = new DescribeSecretCommand({\n        SecretId: testSecretName\n      });\n      \n      await this.client.send(command);\n      return true;\n    } catch (error) {\n      if (error instanceof ResourceNotFoundException) {\n        // This is expected - secret doesn't exist, but connection works\n        return true;\n      }\n      \n      console.warn('AWS Secrets Manager connectivity test failed:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get configuration information\n   */\n  getConfig(): AWSSecretsManagerConfig & { secretPrefix: string } {\n    return {\n      ...this.config,\n      secretPrefix: this.secretPrefix\n    };\n  }\n\n  /**\n   * Generate full secret name with prefix\n   */\n  private getSecretName(key: string): string {\n    // Ensure key doesn't start with slash and normalize separators\n    const normalizedKey = key.replace(/^\\/+/, '').replace(/\\/+/g, '/');\n    return `${this.secretPrefix}${normalizedKey}`;\n  }\n\n  /**\n   * Handle AWS Secrets Manager errors with appropriate error types and messages\n   */\n  private handleSecretError(error: any, message: string, returnNull: boolean = true): string | null {\n    if (returnNull && error instanceof ResourceNotFoundException) {\n      // Secret doesn't exist - return null for get operations\n      return null;\n    }\n    \n    let errorMessage = message;\n    let shouldThrow = true;\n    \n    if (error instanceof ResourceNotFoundException) {\n      errorMessage += ' - Secret not found';\n    } else if (error instanceof InvalidRequestException) {\n      errorMessage += ' - Invalid request parameters';\n    } else if (error instanceof InvalidParameterException) {\n      errorMessage += ' - Invalid parameter value';\n    } else if (error instanceof DecryptionFailureException) {\n      errorMessage += ' - Failed to decrypt secret (check KMS permissions)';\n    } else if (error instanceof InternalServiceErrorException) {\n      errorMessage += ' - AWS internal service error (temporary)';\n      // For internal service errors, we might want to retry\n    } else if (error instanceof ResourceExistsException) {\n      errorMessage += ' - Secret already exists';\n    } else {\n      errorMessage += ` - ${error.message || 'Unknown error'}`;\n    }\n    \n    if (shouldThrow) {\n      throw new SecretManagerError(errorMessage, error.name);\n    }\n    \n    return null;\n  }\n}\n\n/**\n * Factory function to create AWS Secrets Manager provider with environment-based configuration\n */\nexport function createAWSSecretsManagerProvider(\n  customConfig?: Partial<AWSSecretsManagerConfig>,\n  secretPrefix?: string\n): AWSSecretsManagerProvider {\n  const config: AWSSecretsManagerConfig = {\n    region: process.env.AWS_REGION || process.env.AWS_DEFAULT_REGION,\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n    sessionToken: process.env.AWS_SESSION_TOKEN,\n    ...customConfig\n  };\n  \n  const prefix = secretPrefix || process.env.AWS_SECRETS_PREFIX || 'hallucifix/';\n  \n  return new AWSSecretsManagerProvider(config, prefix);\n}\n\n/**\n * Helper function to check if AWS credentials are available\n */\nexport function hasAWSCredentials(): boolean {\n  return !!(process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) ||\n         !!(process.env.AWS_PROFILE) ||\n         !!(process.env.AWS_ROLE_ARN) ||\n         // Check for EC2 instance metadata service (when running on EC2)\n         !!(process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) ||\n         // Check for ECS task role\n         !!(process.env.AWS_CONTAINER_CREDENTIALS_FULL_URI);\n}\n"